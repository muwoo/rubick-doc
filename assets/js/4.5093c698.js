(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{367:function(t,s,a){t.exports=a.p+"assets/img/10.184d861e.png"},368:function(t,s,a){t.exports=a.p+"assets/img/2.ac46ee08.gif"},369:function(t,s,a){t.exports=a.p+"assets/img/11.1b0ef199.png"},370:function(t,s,a){t.exports=a.p+"assets/img/proxySetting.a16c1a2e.png"},384:function(t,s,a){"use strict";a.r(s);var r=a(42),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,r=t._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"网络"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#网络"}},[t._v("#")]),t._v(" 网络")]),t._v(" "),r("h2",{attrs:{id:"抓包"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#抓包"}},[t._v("#")]),t._v(" 抓包")]),t._v(" "),r("p",[t._v("点击 ⏩ 开始录制网络请求，测试网页中所有的的"),r("code",[t._v("['application/json', 'text/html']")]),t._v(" 请求将会被默认代理。 "),r("img",{attrs:{width:"100%",src:a(367)}})]),t._v(" "),r("h2",{attrs:{id:"mock"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mock"}},[t._v("#")]),t._v(" mock")]),t._v(" "),r("p",[t._v("双击需要 mock 的请求，然后进入 mock 状态，点击 mock 列表里面的请求，进入编辑状态后，即可对对应接口进行 mock 操作。 "),r("img",{attrs:{width:"100%",src:a(368)}})]),t._v(" "),r("h3",{attrs:{id:"分场景-mock"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分场景-mock"}},[t._v("#")]),t._v(" 分场景 mock")]),t._v(" "),r("p",[t._v("假设我们请求了后端同一个接口，但是需要根据入参不同来返回不同的结果，这种情况下怎么处理呢？如果使用 rubick 将会非常方便。直接把需要 mock 的\n接口加入到 mock 列表中，然后选择需要分场景 mock 的接口，勾选"),r("code",[t._v("匹配参数")]),t._v("选项即可自动根据入参来匹配对于返回结果\n"),r("img",{attrs:{width:"100%",src:a(369)}})]),t._v(" "),r("h2",{attrs:{id:"代理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#代理"}},[t._v("#")]),t._v(" 代理")]),t._v(" "),r("p",[t._v("由于 anyproxy 内部原因，目前只支持代理到本地 ,点击"),r("code",[t._v("工具")]),t._v("按钮进入绑定页面")]),t._v(" "),r("img",{attrs:{src:a(370)}})])}),[],!1,null,null,null);s.default=e.exports}}]);